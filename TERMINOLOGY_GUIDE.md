# CluMPシミュレータ専門用語解説

このドキュメントでは、CluMPシミュレータを理解するために必要な専門用語を体系的に解説します。

## 📚 目次

1. [基本概念](#基本概念)
2. [ストレージ・I/O関連](#ストレージio関連)
3. [キャッシュ関連](#キャッシュ関連)
4. [プリフェッチ関連](#プリフェッチ関連)
5. [マルコフ連鎖関連](#マルコフ連鎖関連)
6. [CluMP固有の概念](#clump固有の概念)
7. [性能評価指標](#性能評価指標)
8. [アルゴリズム用語](#アルゴリズム用語)

---

## 基本概念

### **ブロック (Block)**
- **定義**: ストレージデバイス（HDD/SSD）上のデータの最小単位
- **サイズ**: 通常512バイト〜4KB
- **例**: ファイルを読み書きする際の基本単位
- **ブロック番号**: ストレージ上の各ブロックに付けられた一意の識別番号

### **アクセストレース (Access Trace)**
- **定義**: アプリケーションがストレージにアクセスした履歴記録
- **形式**: 通常「時刻, ブロック番号, 読み書き種別」を含む
- **用途**: ストレージ性能の分析やシミュレーションの入力データ
- **例**: `[1001, 1002, 1005, 1003, 1004, ...]` （アクセスしたブロック番号の列）

### **ワークロード (Workload)**
- **定義**: システムに与えられる処理負荷のパターン
- **種類**:
  - **順次アクセス**: 連続したブロックを順番にアクセス
  - **ランダムアクセス**: 不規則なブロックをアクセス
  - **混在型**: 順次とランダムが混在

---

## ストレージ・I/O関連

### **I/O (Input/Output)**
- **定義**: コンピュータと外部デバイス（ストレージ）間のデータのやり取り
- **種類**:
  - **読み込み (Read)**: ストレージからメモリへデータを転送
  - **書き込み (Write)**: メモリからストレージへデータを転送

### **レイテンシ (Latency)**
- **定義**: I/O要求を出してから完了するまでの時間
- **HDD**: 通常5-15ms（機械的動作のため遅い）
- **SSD**: 通常0.1-1ms（電子的動作のため高速）

### **スループット (Throughput)**
- **定義**: 単位時間あたりに処理できるデータ量
- **単位**: MB/秒、IOPS（I/O per Second）
- **重要性**: システム全体の性能に直結

### **シーケンシャルアクセス (Sequential Access)**
- **定義**: 連続したブロックを順番にアクセスすること
- **特徴**: HDDで高速、予測しやすい
- **例**: 大きなファイルの読み込み、動画再生

### **ランダムアクセス (Random Access)**
- **定義**: 不規則な位置のブロックをアクセスすること
- **特徴**: HDDで低速、予測困難
- **例**: データベース検索、小さなファイルの頻繁なアクセス

---

## キャッシュ関連

### **キャッシュ (Cache)**
- **定義**: 高速なメモリに一時的にデータを保存する仕組み
- **目的**: 遅いストレージアクセスを高速なメモリアクセスで代替
- **階層**: CPU → メモリ → ストレージの中間に位置

### **キャッシュヒット (Cache Hit)**
- **定義**: 要求されたデータがキャッシュ内に存在する状況
- **結果**: 高速アクセス（ストレージアクセス不要）
- **理想**: ヒット率が高いほど性能向上

### **キャッシュミス (Cache Miss)**
- **定義**: 要求されたデータがキャッシュ内に存在しない状況
- **結果**: 遅いストレージアクセスが必要
- **対応**: データをストレージから読み込んでキャッシュに格納

### **ヒット率 (Hit Rate)**
- **定義**: 全アクセスに対するキャッシュヒットの割合
- **計算式**: `ヒット数 ÷ 総アクセス数 × 100%`
- **例**: ヒット率90% = 10回中9回がキャッシュから高速取得

### **LRU (Least Recently Used)**
- **定義**: 最も長い間使われていないデータを追い出すキャッシュ管理方式
- **原理**: 最近使ったデータは再度使われる可能性が高い
- **実装**: アクセス順序を記録し、古いものから削除

### **エビクション (Eviction)**
- **定義**: キャッシュが満杯になった時にデータを追い出すこと
- **タイミング**: 新しいデータを入れる際にスペースが必要な時
- **方式**: LRU、LFU（最も使用頻度が低い）、FIFO（先入先出）など

---

## プリフェッチ関連

### **プリフェッチ (Prefetch)**
- **定義**: まだ要求されていないが、将来必要になりそうなデータを事前に読み込むこと
- **目的**: 将来のキャッシュミスを予防し、性能を向上させる
- **リスク**: 予測が外れると無駄なI/Oとメモリ消費

### **先読み (Read-ahead)**
- **定義**: 現在読んでいる位置の先のデータを予測して読み込むこと
- **Linux read-ahead**: OSが提供する基本的な先読み機能
- **固定窓方式**: 現在位置から固定サイズ分を機械的に先読み

### **プリフェッチ窓 (Prefetch Window)**
- **定義**: 一度にプリフェッチするブロック数の範囲
- **例**: 窓サイズ16 = 予測したブロックから16ブロック分を読み込み
- **調整**: 大きすぎると無駄、小さすぎると効果不十分

### **プリフェッチ効率 (Prefetch Efficiency)**
- **定義**: プリフェッチしたデータのうち実際に使用された割合
- **計算式**: `使用されたプリフェッチ数 ÷ 総プリフェッチ数 × 100%`
- **理想値**: 100%（全てのプリフェッチが有効活用）

### **無駄プリフェッチ (Wasted Prefetch)**
- **定義**: プリフェッチしたが使用されずにキャッシュから追い出されたデータ
- **問題**: I/O帯域とメモリの無駄遣い
- **対策**: より精密な予測アルゴリズムの使用

---

## マルコフ連鎖関連

### **マルコフ連鎖 (Markov Chain)**
- **定義**: 現在の状態のみに基づいて次の状態を決定する確率モデル
- **特徴**: 過去の履歴は直前の状態に集約される
- **応用**: アクセスパターンの予測、自然言語処理など

### **状態 (State)**
- **定義**: マルコフ連鎖における各時点でのシステムの状況
- **CluMPでの例**: 現在アクセス中のチャンクID
- **遷移**: ある状態から別の状態への変化

### **状態遷移 (State Transition)**
- **定義**: ある状態から別の状態への変化
- **例**: チャンク5からチャンク8へのアクセス移動
- **記録**: 「状態A → 状態B」の発生回数を蓄積

### **遷移確率 (Transition Probability)**
- **定義**: ある状態から特定の状態に遷移する確率
- **計算**: `特定遷移の回数 ÷ その状態からの総遷移回数`
- **例**: チャンク5の後にチャンク8が60%の確率で来る

### **MCRow (Markov Chain Row)**
- **定義**: マルコフ連鎖の1つの状態に対応する遷移情報
- **構成**: CN1〜CN3（候補）とP1〜P3（確率）のペア
- **機能**: 各チャンクから次に来やすいチャンクを予測

---

## CluMP固有の概念

### **CluMP**
- **正式名称**: CLUstered Markov-chain Prefetching
- **概要**: マルコフ連鎖とクラスタリングを組み合わせたプリフェッチ手法
- **特徴**: メモリ効率と予測精度の両立

### **チャンク (Chunk)**
- **定義**: 複数のブロックをまとめた単位
- **目的**: マルコフ連鎖の状態数を削減し、メモリ使用量を抑制
- **サイズ**: CHsize（例：8ブロック = 1チャンク）
- **計算**: `チャンクID = ブロックID ÷ チャンクサイズ`

### **クラスタ (Cluster)**
- **定義**: 複数のチャンクをまとめたグループ
- **目的**: MCRowの管理単位、メモリ使用量のさらなる最適化
- **サイズ**: CLsize（例：32チャンク = 1クラスタ）
- **計算**: `クラスタID = チャンクID ÷ クラスタサイズ`

### **CN1, CN2, CN3**
- **定義**: MCRowに記録される次候補チャンクの番号
- **順序**: CN1が最も可能性が高い候補
- **制限**: 最大3つまで記録（メモリ節約）

### **P1, P2, P3**
- **定義**: CN1, CN2, CN3に対応する遷移確率
- **計算**: 各候補への遷移回数から算出
- **正規化**: P1 + P2 + P3 = 1.0

### **オンデマンド割り当て (On-demand Allocation)**
- **定義**: MCRowを必要になった時点で動的に作成する方式
- **利点**: 未使用チャンクのメモリ消費を回避
- **実装**: アクセスが発生した時点でMCRowを生成

---

## 性能評価指標

### **総アクセス数 (Total Accesses)**
- **定義**: シミュレーション中に発生した全I/O要求数
- **用途**: 他の指標の分母として使用

### **キャッシュヒット数 (Cache Hits)**
- **定義**: キャッシュから直接データを取得できた回数
- **重要性**: システム性能の直接的な指標

### **プリフェッチ総数 (Prefetch Total)**
- **定義**: アルゴリズムによって実行されたプリフェッチの総回数
- **内訳**: 有効利用分 + 無駄になった分

### **プリフェッチ使用数 (Prefetch Used)**
- **定義**: プリフェッチしたデータが実際にアクセスされた回数
- **意味**: プリフェッチの成功例

### **未使用プリフェッチ追出数 (Prefetch Unused Evicted)**
- **定義**: 使用されずにキャッシュから追い出されたプリフェッチ数
- **問題**: リソースの無駄遣いを示す指標

### **MC行数 (MC Rows)**
- **定義**: 生成されたMCRowの総数
- **意味**: アルゴリズムのメモリ消費量を示す
- **最適化**: 少ない行数で高い性能を実現することが理想

---

## アルゴリズム用語

### **ベースライン (Baseline)**
- **定義**: 比較対象となる基本的な手法
- **本システム**: Linux read-ahead相当のシンプルな先読み
- **目的**: CluMPの効果を客観的に評価

### **合成ワークロード (Synthetic Workload)**
- **定義**: 実験用に人工的に生成されたアクセスパターン
- **パラメータ**: 順次確率、ジャンプ確率、ファイル数など
- **利点**: 条件を制御した実験が可能

### **パラメータ最適化 (Parameter Optimization)**
- **定義**: 最高性能を得るためのパラメータ値の探索
- **手法**: グリッドサーチ、ヒートマップ分析
- **対象**: チャンクサイズ、クラスタサイズ、キャッシュサイズなど

### **学習フェーズ (Learning Phase)**
- **定義**: アルゴリズムがアクセスパターンを学習する期間
- **特徴**: 初期段階は予測精度が低い
- **重要性**: 十分な学習データが蓄積されると予測精度が向上

### **定常状態 (Steady State)**
- **定義**: 学習が十分進み、性能が安定した状態
- **判定**: ヒット率の変動が小さくなった時点
- **評価**: 通常、定常状態での性能で手法を比較

---

## 📖 用語の関係性

```
ブロック → チャンク → クラスタ → MCRow
   ↓        ↓        ↓        ↓
 基本単位  学習単位  管理単位  予測単位

アクセストレース → マルコフ連鎖学習 → 状態遷移予測 → プリフェッチ実行
```

---

## 🎯 実践での理解

### **シミュレーション実行例**
```bash
python clump_simulator.py
```

**出力の読み方**:
- `総アクセス数: 25000` → 25,000回のI/O要求を処理
- `ヒット率: 0.485` → 48.5%がキャッシュヒット
- `プリフェッチ効率: 0.577` → 57.7%のプリフェッチが有効

### **用語の具体例**
- **チャンクサイズ8**: ブロック0-7が「チャンク0」、ブロック8-15が「チャンク1」
- **遷移**: 「チャンク5 → チャンク8」のアクセス移動を記録
- **予測**: 「チャンク5の次は70%の確率でチャンク8」として学習

この用語解説を参考に、CluMPシミュレータをより深く理解してください！