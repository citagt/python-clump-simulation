# 要件定義（CluMPシミュレータ）

## 1. 目的
- CluMPアルゴリズムをシミュレーションにより再現し、Linux read-aheadや単純なプリフェッチ方式と比較可能にする。  
- 論文の性能評価指標（ヒット率、無駄プリフェッチ率、メモリ消費量など）を再現し、動作原理を検証する。  

## 2. 入力データ
1. I/Oアクセス・トレース
   - 各アクセスは「ディスクブロック番号」で表現。
   - 出典は以下のいずれか：
     - 実環境のトレース（blktrace, iosnoop など）
     - 論文と同様のテストケース（VM起動ログ、カーネルビルドログ）
     - 合成トレース（ランダム＋逐次アクセスの混合）
   - フォーマット（例）:  
     block_id timestamp process_id ...
     シミュレータでは最低限 block_id が必要。

2. パラメータ設定
   - CHsize（チャンクの大きさ：ブロック数）
   - CLsize（クラスタの大きさ：チャンク数）
   - CacheSize（キャッシュ容量：ブロック数）
   - PrefetchWindow（プリフェッチ時に読み込むブロック数）

## 3. 出力（評価指標）
1. ヒット率  
2. プリフェッチ統計  
   - PrefetchTotal：プリフェッチされたブロック数  
   - PrefetchUsed：後に実際アクセスされ、ヒットに貢献したプリフェッチ数  
   - PrefetchUnusedEvicted：使われずキャッシュから追い出されたプリフェッチ数  
   - PrefetchEfficiency = PrefetchUsed / PrefetchTotal
3. メモリ消費（生成されたMCRow数）  
4. 処理時間（オプション）  

## 4. 機能要件
### (A) データ構造
- チャンク (Chunk)：ディスクブロックをCHsize単位にまとめる  
- クラスタ (Cluster)：複数のチャンクをCLsize単位にまとめる  
- MCRow：各チャンクに対して CN1..CN3 と P1..P3 を保持し、遷移を記録  

### (B) アルゴリズム処理フロー
1. アクセス処理：キャッシュを確認し、ヒット/ミスを判定  
2. キャッシュ更新：ミスならブロックを読み込み、LRU方式で管理  
3. MC更新：「前チャンク → 現チャンク」の遷移を更新  
4. 予測・プリフェッチ：CN1を参照し、予測チャンクをPrefetchWindow分ロード  

## 5. 非機能要件
- 実装言語：Python 3.x  
- 依存ライブラリ：標準ライブラリのみ（評価用にNumPy/Matplotlib可）  
- 実行時間：10万～100万アクセスの処理が可能  
- 再現性：乱数はシード固定可能  

## 6. 拡張要件（卒論向け発展）
- 比較実験：Linux read-aheadやpreloadの簡易実装と比較  
- 可視化：ヒット率推移やパラメータ差のヒートマップ  
- 統合モデル：「preloadのファイル予測」＋「CluMPのブロック予測」の二層構造  