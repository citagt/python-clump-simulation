# CluMP Simulator - CLUstered Markov-chain Prefetching

![Python](https://img.shields.io/badge/python-3.7+-blue.svg)
![Status](https://img.shields.io/badge/status-研究用-orange.svg)

**CluMPシミュレータ** は、ディスクI/Oのアクセスパターンを学習して次のアクセス先を予測し、事前にデータを読み込むことでストレージ性能を向上させるアルゴリズムのシミュレーションツールです。

## 📋 目次

- [CluMPとは](#clumpとは)
- [環境構築](#環境構築)
- [クイックスタート](#クイックスタート)
- [使い方](#使い方)
- [設定パラメータ](#設定パラメータ)
- [評価指標](#評価指標)
- [実行結果の見方](#実行結果の見方)

## 📚 CluMPとは

CluMP（CLUstered Markov-chain Prefetching）は、以下の特徴を持つプリフェッチアルゴリズムです：

### 🎯 基本概念
- **チャンク**: 複数のディスクブロック（例：16ブロック）をまとめた単位
- **マルコフ連鎖**: 「チャンクA → チャンクB」の遷移パターンを学習
- **予測プリフェッチ**: 学習結果に基づいて次のアクセス先を予測し、事前に読み込み

### � なぜ有効か
従来の単純な先読みとは異なり、過去のアクセスパターンから統計的に最も可能性の高いデータを予測するため、より精度の高いプリフェッチが可能です。

## 🔧 環境構築

### 1. Python仮想環境の作成

```bash
# 仮想環境作成
python -m venv .venv

# 仮想環境の有効化（Windows）
.venv\Scripts\activate

# 仮想環境の有効化（Linux/Mac）
source .venv/bin/activate
```

### 2. 必要パッケージのインストール

```bash
# 基本実行（標準ライブラリのみ）
# → 追加インストール不要

# 可視化機能を使用する場合
pip install matplotlib numpy seaborn
```

### 3. 動作確認

```bash
python clump_simulator.py
```

## ⚡ クイックスタート

### 30秒で体験

```python
from clump_simulator import run_clump_simulation, TraceGenerator

# 1. 合成ワークロード生成
trace = TraceGenerator.generate_synthetic_trace(
    n_events=10000,
    num_files=20, 
    sequential_prob=0.6
)

# 2. CluMPシミュレーション実行
results = run_clump_simulation(trace=trace)

# 3. 結果確認
print(f"ヒット率: {results['hit_rate']:.3f}")
print(f"プリフェッチ効率: {results['prefetch_efficiency']:.3f}")
```

## 📖 使い方

### 🔍 2つのメインファイルの違い

#### `clump_simulator.py` - 基本エンジン
**何をするファイル？**
- CluMPアルゴリズムの**1回実行**
- **特定の設定**での動作確認

```bash
python clump_simulator.py
# → 1つのパラメータセットで実行（30秒程度）
```

**使う場面:**
- ✅ アルゴリズムの動作を理解したい
- ✅ 特定設定での結果が知りたい
- ✅ 軽量・高速実行が欲しい

**出力例:**
```
ヒット率: 0.679 (67.9%)
プリフェッチ効率: 0.404 (40.4%)
チャンクサイズ: 16 ブロック
```

#### `performance_evaluator.py` - 実験・分析ツール
**何をするファイル？**
- **複数設定の自動比較**（例：12パターン）
- **最適パラメータの発見**
- **ベースライン手法との比較**

```bash
python performance_evaluator.py
# → 12パターン自動実行 + 比較分析 + グラフ生成（5-10分）
```

**使う場面:**
- ✅ 最適なパラメータを見つけたい
- ✅ 従来手法との比較をしたい
- ✅ 論文用のグラフが欲しい

**出力例:**
```
🏆 最適パラメータ:
   チャンクサイズ: 16, クラスタサイズ: 16
   ヒット率: 67.9%
📈 ベースライン比較:
   改善率: +25.0%
📁 グラフ生成: visualization_output/
```

### � 実行手順

#### 1. 初回体験（推奨）
```bash
# まずは基本動作を確認
python clump_simulator.py
# → モード3「デモ実行」を選択
```

#### 2. 本格的な性能評価
```bash
# 最適パラメータ発見 + 比較分析
python performance_evaluator.py
# → 自動で12パターン実行 + グラフ生成
```

#### 3. 可視化のみ
```bash
# グラフ機能の動作確認
python visualization.py
```

## ⚙️ 設定パラメータ

### 主要パラメータの意味

| パラメータ | 説明 | 効果 | 推奨値 |
|------------|------|------|--------|
| `chunk_size` | チャンクサイズ（ブロック数） | 小さいほど細かい予測、大きいほど単純化 | 8-32 |
| `cluster_size` | クラスタサイズ（チャンク数） | メモリ効率に影響 | 16-64 |
| `cache_size` | キャッシュサイズ（ブロック数） | 大きいほどヒット率向上、メモリ消費増 | 4096 |
| `prefetch_window` | プリフェッチ窓（ブロック数） | 先読み量、大きいほど積極的 | 16-32 |

### パラメータ調整の指針

#### chunk_size（チャンクサイズ）
- **小さい値（4-8）**: ランダムアクセスが多い場合に有効、メモリ使用量多
- **大きい値（16-32）**: 順次アクセスが多い場合に有効、メモリ使用量少

#### cluster_size（クラスタサイズ）  
- **小さい値（16-32）**: 予測精度重視、メモリ使用量多
- **大きい値（64-128）**: メモリ効率重視、予測精度は粗い

## � 評価指標

### 基本指標

#### ヒット率（Hit Rate）
- **意味**: キャッシュにデータが存在した割合
- **計算式**: `ヒット数 / 総アクセス数`
- **目標**: 高いほど良い（通常50-80%）

#### プリフェッチ効率（Prefetch Efficiency）
- **意味**: プリフェッチしたデータが実際に使われた割合
- **計算式**: `使用されたプリフェッチ数 / 総プリフェッチ数`
- **目標**: 高いほど良い（30-70%が一般的）

#### メモリ使用量（MC Rows）
- **意味**: 学習用データ構造（MCRow）の数
- **特徴**: 少ないほどメモリ効率が良い
- **目安**: 数百〜数千程度

### ベースライン比較

#### 比較手法
- **Linux read-ahead相当**: 単純な先読み手法
- **改善率**: CluMPがベースラインより何%良いか

## 📈 実行結果の見方

### `clump_simulator.py`の結果例

```
============================================================
CluMP シミュレーション結果
============================================================
📈 基本統計:
   総アクセス数: 25,000
   キャッシュヒット数: 12,284
   ヒット率: 0.491 (49.1%)

🎯 プリフェッチ統計:
   プリフェッチ総数: 44,456
   プリフェッチ使用数: 6,559
   プリフェッチ効率: 0.148 (14.8%)

💾 メモリ消費:
   MC行数: 1,592
```

### `performance_evaluator.py`の結果例

```
🏆 最適パラメータ発見:
   チャンクサイズ: 16 ブロック
   クラスタサイズ: 16 チャンク
   ヒット率: 0.679 (67.9%)

📈 ベースライン比較:
   CluMP: 67.9%
   単純先読み: 54.3%
   改善率: +25.0%

📁 生成ファイル:
   visualization_output/session_YYYYMMDD_HHMMSS/
   ├── parameter_heatmaps/     # パラメータ比較
   ├── baseline_comparison/    # 手法比較
   └── summary_report.txt     # 詳細レポート
```

### 結果の解釈

#### 🎯 良好な結果の目安
- **ヒット率**: 60%以上
- **プリフェッチ効率**: 40%以上  
- **改善率**: ベースラインより20%以上向上

#### 📊 どちらのファイルを使うべき？

**初めて使う場合:**
1. `clump_simulator.py`でアルゴリズムを理解
2. `performance_evaluator.py`で本格的な分析

**研究・論文作成:**
- `performance_evaluator.py`で全自動分析
- 生成されたグラフをそのまま使用可能

### 可視化出力

可視化機能（matplotlib利用時）では以下が生成されます：

- **ヒット率推移チャート**: 学習効果の確認
- **パラメータヒートマップ**: 最適設定の特定
- **ベースライン比較チャート**: 改善効果の確認

出力先：`visualization_output/session_YYYYMMDD_HHMMSS/`

## � トラブルシューティング

### よくある問題

#### 可視化が表示されない
```bash
pip install matplotlib numpy seaborn
```

#### メモリ不足でエラー
```python
# トレースサイズを小さく設定
trace = TraceGenerator.generate_synthetic_trace(n_events=5000)
```

#### 実行が遅い
- `n_events`（アクセス数）を減らす
- `cache_size`を小さくする

## 📄 ファイル構成

```
python-markov-chain/
├── clump_simulator.py       # メインシミュレータ
├── performance_evaluator.py # 性能評価・比較実験
├── visualization.py         # 可視化機能
├── requirements_definition.md # 要件定義書
└── README.md               # このファイル
```

## 📚 技術詳細

### アルゴリズムの流れ
1. **アクセス処理**: キャッシュ確認、ヒット/ミス判定
2. **キャッシュ更新**: ミス時のデータ読み込み、LRU管理
3. **学習更新**: マルコフ連鎖の遷移確率更新
4. **予測プリフェッチ**: 学習結果に基づく先読み実行

### 実装の特徴
- Python標準ライブラリのみで動作
- オンライン学習による適応的性能向上
- メモリ効率的なオンデマンド割り当て
- 詳細な統計追跡と分析機能

---

**CluMP Simulator** - ストレージI/O最適化の研究・学習ツール 🚀